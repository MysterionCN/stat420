---
title: "Week 6 - Simulation Project"
author: "STAT 420, Summer 2020, Jilin Tian"
date: ''
output:
  html_document:
    theme: readable
    toc: yes
  pdf_document: default
  word_document:
    toc: yes
urlcolor: cyan
---

***

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80)
library(knitr)
opts_chunk$set(cache = TRUE, autodep = TRUE)
```

# Directions

This is an **individual** project. This is NOT like a homework assignment. This is NOT an assignment where collaboration is permissible. Discussion of question intent, coding problems/issues, and project administration may be discussed on the message board on a limited basis. However, sharing, copying, or providing any part of this project to another student is an infraction of the University’s rules on academic integrity. Any violation will be punished as severely as possible.

- Your project must be submitted through Coursera. You are required to upload one `.zip` file, named `yourNetID-sim-proj.zip`, which contains:
  + Your RMarkdown file which should be saved as `yourNetID-sim-proj.Rmd`.
  + The result of knitting your RMarkdown file as `yourNetID-sim-proj.html`.
  + Any outside data provided as a `.csv` file. (In this case, `study_1.csv` and `study_2.csv`.)
- Your `.Rmd` file should be written such that, when stored in a folder with any data you are asked to import, it will knit properly without modification. If your `.zip` file is organized properly, this should not be an issue.
- Include your name and NetID in the final document, not only in your filenames.

This project consists of **three** simulation studies. Unlike a homework assignment, these "exercises" are not broken down into parts (e.g., a, b, c), and so your analysis will not be similarly partitioned. Instead, your document should be organized more like a true project report, and it should use the overall format:

- Simulation Study 1
- Simulation Study 2
- Simulation Study 3

Within each of the simulation studies, you should use the format:

- Introduction
- Methods
- Results
- Discussion

The **introduction** section should relay what you are attempting to accomplish. It should provide enough background to your work such that a reader would not need this directions document to understand what you are doing. (Basically, assume the reader is mostly familiar with the concepts from the course, but not this project.)

The **methods** section should contain the majority of your “work.” This section will contain the bulk of the `R` code that is used to generate the results. Your `R` code is not expected to be perfect idiomatic `R`, but it is expected to be understood by a reader without too much effort. Use RMarkdown and code comments to your advantage to explain your code if needed.

The **results** section should contain numerical or graphical summaries of your results as they pertain to the goal of each study.

The **discussion** section should contain discussion of your results. The discussion section should contain discussion of your results. Potential topics for discussion are suggested at the end of each simulation study section, but they are not meant to be an exhaustive list. These simulation studies are meant to be explorations into the principles of statistical modeling, so do not limit your responses to short, closed form answers as you do in homework assignments. Use the potential discussion questions as a starting point for your response.

- Your resulting `.html` file will be considered a self-contained “report,” which is the material that will determine the majority of your grade. Be sure to visibly include all `R` code and output that is *relevant*. (You should not include irrelevant code you tried that resulted in error or did not answer the question correctly.)
- Grading will be based on a combination of completing the required tasks, discussion of results, `R` usage, RMarkdown usage, and neatness and organization. For full details see the provided rubric.
- At the beginning of *each* of the three simulation studies, set a seed equal to your birthday, as is done on homework. (It should be the first code run for each study.) These should be the only three times you set a seed.

```{r}
birthday = 19991021
set.seed(birthday)
```

# Simulation Study 1: Significance of Regression

In this simulation study we will investigate the significance of regression test. We will simulate from two different models:

1. The **"significant"** model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 3$,
- $\beta_1 = 1$,
- $\beta_2 = 1$,
- $\beta_3 = 1$.


2. The **"non-significant"** model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 3$,
- $\beta_1 = 0$,
- $\beta_2 = 0$,
- $\beta_3 = 0$.

For both, we will consider a sample size of $25$ and three possible levels of noise. That is, three values of $\sigma$.

- $n = 25$
- $\sigma \in (1, 5, 10)$

Use simulation to obtain an empirical distribution for each of the following values, for each of the three values of $\sigma$, for both models.

- The **$F$ statistic** for the significance of regression test.
- The **p-value** for the significance of regression test
- **$R^2$**

For each model and $\sigma$ combination, use $2000$ simulations. For each simulation, fit a regression model of the same form used to perform the simulation.

Use the data found in [`study_1.csv`](study_1.csv) for the values of the predictors. These should be kept constant for the entirety of this study. The `y` values in this data are a blank placeholder.

Done correctly, you will have simulated the `y` vector $2 (models)×3 (sigmas)×2000 (sims)=12000$ times.

Potential discussions:

- Do we know the true distribution of any of these values?
- How do the empirical distributions from the simulations compare to the true distributions? (You could consider adding a curve for the true distributions if you know them.)
- How are each of the $F$ statistic, the p-value, and $R^2$ related to $\sigma$? Are any of those relationships the same for the significant and non-significant models?

Additional things to consider:

- Organize the plots in a grid for easy comparison.


**Introduction** : In this simulation study, we will simulate from a "significant" model and a "non-significant" model, first, we would have to import data from [`study_1.csv`] using read.csv() function. And store the data into a data frame called sim_data. 

```{r}
birthday = 19991021
set.seed(birthday)
n = 25
sim_1 = read.csv("study_1.csv")
x1 = sim_1$x1
x2 = sim_1$x2
x3 = sim_1$x3
y = sim_1$y
sim_data = data.frame(y, x1, x2, x3)


```


**Methods** : First, we would like to input the value for $\beta_j$ and $\sigma$ , Then, we will  create f_j, pval_j, r_sq_j,three vectors of length 2000 that will store the result from the simulation. Since there will be six simulations in this study, we will have to create 18 vectors(3 vectors for each model).

```{r}
birthday = 19991021
set.seed(birthday)
beta_0 = 3
beta_1 = 1
beta_2 = 1
beta_3 = 1
sigma_1 = 1
sigma_2 = 5
sigma_3 = 10
sim_data_1 = sim_data
f_1 = rep(0, times = 2000) #Three vectors will store the result from the simulation
pval_1 = rep(0, times = 2000)
r_sq_1 = rep(0, times = 2000)
f_2 = rep(0, times = 2000)
pval_2 = rep(0, times = 2000)
r_sq_2 = rep(0, times = 2000)
sim_data_2 = sim_data
f_3 = rep(0, times = 2000)
pval_3 = rep(0, times = 2000)
r_sq_3 = rep(0, times = 2000)
sim_data_3 = sim_data
f_4 = rep(0, times = 2000)
pval_4 = rep(0, times = 2000)
r_sq_4 = rep(0, times = 2000)
sim_data_4 = sim_data
f_5 = rep(0, times = 2000)
pval_5 = rep(0, times = 2000)
r_sq_5 = rep(0, times = 2000)
sim_data_5 = sim_data
f_6 = rep(0, times = 2000)
pval_6 = rep(0, times = 2000)
r_sq_6 = rep(0, times = 2000)
sim_data_6 = sim_data
```

Then, we will use the for loop to simulate the data and output the fstatistic, p-value, and $R^2$ for each models




```{r}
set.seed(birthday)
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 1)
  sim_data_1$y = beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3 + eps
  fit_1 = lm(y ~ x1 + x2 + x3 , data = sim_data_1)
  null_model = lm(y ~ 1, data = sim_data_1)
  f_1[i] = summary(fit_1)$fstatistic[1]
  pval_1[i] = anova(null_model, fit_1)$"Pr(>F)"[2]
  r_sq_1[i] = summary(fit_1)$r.squared
}
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 5)
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3 + eps
  fit_2 = lm(y ~ x1 + x2 + x3 , data = sim_data_2)
  null_model = lm(y ~ 1, data = sim_data_2)
  f_2[i] = summary(fit_2)$fstatistic[1]
  pval_2[i] = anova(null_model, fit_2)$"Pr(>F)"[2]
  r_sq_2[i] = summary(fit_2)$r.squared
}
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 10)
  sim_data_3$y = beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3 + eps
  fit_3 = lm(y ~ x1 + x2 + x3 , data = sim_data_3)
  null_model = lm(y ~ 1, data = sim_data_3)
  f_3[i] = summary(fit_3)$fstatistic[1]
  pval_3[i] = anova(null_model, fit_3)$"Pr(>F)"[2]
  r_sq_3[i] = summary(fit_3)$r.squared
}
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 1)
  sim_data_4$y = 3  + eps
  fit_4 = lm(y ~ x1 + x2 + x3 , data = sim_data_4)
  null_model = lm(y ~ 1, data = sim_data_4)
  f_4[i] = summary(fit_4)$fstatistic[1]
  pval_4[i] = anova(null_model, fit_4)$"Pr(>F)"[2]
  r_sq_4[i] = summary(fit_4)$r.squared
}
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 5)
  sim_data_5$y = 3  + eps
  fit_5 = lm(y ~ x1 + x2 + x3 , data = sim_data_5)
  null_model = lm(y ~ 1, data = sim_data_5)
  
  f_5[i] = summary(fit_5)$fstatistic[1]
  pval_5[i] = anova(null_model, fit_5)$"Pr(>F)"[2]
  r_sq_5[i] = summary(fit_5)$r.squared
}
for (i in 1:2000) {
  eps = rnorm(25, mean = 0, sd = 10)
  sim_data_6$y = 3  + eps
  fit_6 = lm(y ~ x1 + x2 + x3 , data = sim_data_6)
  null_model = lm(y ~ 1, data = sim_data_6)
  f_6[i] = summary(fit_6)$fstatistic[1]
  pval_6[i] = anova(null_model, fit_6)$"Pr(>F)"[2]
  r_sq_6[i] = summary(fit_6)$r.squared
}

```



**Results** : The result will be the histograms of f_statistic, p-value and R^2  for easy comparison

Model 1 ("significant" model ,$\sigma$ = 1) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)

par(mfrow = c(1, 3))
hist(
  f_1,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)

hist(
  pval_1,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)
hist(
  r_sq_1,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)


```


Model 2 ("significant" model ,$\sigma$ = 5) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)


par(mfrow = c(1, 3))
hist(
  f_2,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)
hist(
  pval_2,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)
hist(
  r_sq_2,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)

```


Model 3 ("significant" model ,$\sigma$ = 10) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)
par(mfrow = c(1, 3))
hist(
  f_3,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)

hist(
  pval_3,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)
hist(
  r_sq_3,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)
```


Model 4 ("non-significant" model ,$\sigma$ = 1) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)



par(mfrow = c(1, 3))
hist(
  f_4,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)
hist(
  pval_4,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)
hist(
  r_sq_4,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)
```



Model 5 ("non-significant" model ,$\sigma$ = 5) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)


par(mfrow = c(1, 3))
hist(
  f_5,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)
hist(
  pval_5,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)

hist(
  r_sq_5,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)
```


Model 6 ("non-significant" model ,$\sigma$ = 10) :
```{r,echo = FALSE}
birthday = 19991021
set.seed(birthday)


par(mfrow = c(1, 3))
hist(
  f_6,
  prob = TRUE,
  breaks = 20,
  xlab = "f_stat",
  main = "",
  border = "navyblue"
)
curve(df(x, 3, 21),
      col = "darkorange",
      add = TRUE,
      lwd = 3)
hist(
  pval_6,
  prob = TRUE,
  xlab = "p-value",
  main = "",
  border = "navyblue"
)

hist(
  r_sq_6,
  prob = TRUE,
  breaks = 20,
  xlab = "R^2",
  main = "",
  border = "navyblue"
)

```


Discussion : 
We don't know the true distribution of p-value and $R^2$, However, we know that F-statistic 's true distribution is F-distribution, and we can add a curve for the true distribution of F-statistic In the significant model. as the $\sigma$ (noise) getting bigger, the p-value seems to be more discrete and  the mean of simulated $R^2$ become smaller. Besides, the histogram of F-statistics fitted the true distribution curve better when the $\sigma$ rises. In non-significant model, The histogram of F-statistics looks like the same as the F-statistics is the same for model 4,5 and 6. The p-value of model 4,5,6 seems like randomly distributed. And the $R^2$ is relatively small  which means less linear relationship between Y and $\beta_0$ = 3 compared to the significant model.

# Simulation Study 2: Using RMSE for Selection?

In homework we saw how Test RMSE can be used to select the “best” model. In this simulation study we will investigate how well this procedure works. Since splitting the data is random, we don’t expect it to work correctly each time. We could get unlucky. But averaged over many attempts, we should expect it to select the appropriate model. 

We will simulate from the model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \beta_4 x_{i4} + \beta_5 x_{i5} + \beta_6 x_{i6} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 0$,
- $\beta_1 = 3$,
- $\beta_2 = -4$,
- $\beta_3 = 1.6$,
- $\beta_4 = -1.1$,
- $\beta_5 = 0.7$,
- $\beta_6 = 0.5$.

We will consider a sample size of $500$ and three possible levels of noise. That is, three values of $\sigma$.

- $n = 500$
- $\sigma \in (1, 2, 4)$

Use the data found in [`study_2.csv`](study_2.csv) for the values of the predictors. These should be kept constant for the entirety of this study. The `y` values in this data are a blank placeholder.

Each time you simulate the data, randomly split the data into train and test sets of equal sizes (250 observations for training, 250 observations for testing).

For each, fit **nine** models, with forms:

- `y ~ x1`
- `y ~ x1 + x2`
- `y ~ x1 + x2 + x3`
- `y ~ x1 + x2 + x3 + x4`
- `y ~ x1 + x2 + x3 + x4 + x5`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6`, the correct form of the model as noted above
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9`

For each model, calculate Train and Test RMSE.

\[
\text{RMSE}(\text{model, data}) = \sqrt{\frac{1}{n} \sum_{i = 1}^{n}(y_i - \hat{y}_i)^2}
\]

Repeat this process with $1000$ simulations for each of the $3$ values of $\sigma$. For each value of $\sigma$, create a plot that shows how average Train RMSE and average Test RMSE changes as a function of model size. Also show the number of times the model of each size was chosen for each value of $\sigma$.

Done correctly, you will have simulated the $y$ vector $3×1000=3000$ times. You will have fit $9×3×1000=27000$ models. A minimal result would use $3$ plots. Additional plots may also be useful.

Potential discussions:

- Does the method **always** select the correct model? On average, does is select the correct model?
- How does the level of noise affect the results?


**Introduction** : For this study, we will need to import the data from [`study_2.csv`] first. Then, we need to create the vectors to store the results from simulation.
```{r}
sim_2 = read.csv("study_2.csv")
x0 = rep(1, times = 25)
x1 = sim_2$x1
x2 = sim_2$x2
x3 = sim_2$x3
x4 = sim_2$x4
x5 = sim_2$x5
x6 = sim_2$x6
x7 = sim_2$x7
x8 = sim_2$x8
x9 = sim_2$x9
y = sim_2$y
X = cbind(x0, x1, x2, x3)
sim_data_2 = data.frame(y, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
beta_0 = 0
beta_1 = 3
beta_2 = -4
beta_3 = 1.6
beta_4 = -1.1
beta_5 = 0.7
beta_6 = 0.5
```


```{r,echo = FALSE}
set.seed(birthday)
u = 1:nrow(sim_2)
sim_2_trn = sample(u, 250, replace = FALSE)
sim_2_tst = setdiff(u, sim_2_trn)
trn_data = sim_2[sim_2_trn,]
tst_data = sim_2[sim_2_tst,]
trn_model_1 = lm(y ~ x1, data = trn_data)
trn_model_2 = lm(y ~ x1 + x2, data = trn_data)
trn_model_3 = lm(y ~ x1 + x2 + x3, data = trn_data)
trn_model_4 = lm(y ~ x1 + x2 + x3 + x4, data = trn_data)
trn_model_5 = lm(y ~ x1 + x2 + x3 + x4 + x5, data = trn_data)
trn_model_6 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6, data = trn_data)
trn_model_7 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7, data = trn_data)
trn_model_8 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8, data = trn_data)
trn_model_9 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9, data = trn_data)
RMSE_trn1_1 = rep(0, times = 1000)
RMSE_trn2_1 = rep(0, times = 1000)
RMSE_trn3_1 = rep(0, times = 1000)
RMSE_trn4_1 = rep(0, times = 1000)
RMSE_trn5_1 = rep(0, times = 1000)
RMSE_trn6_1 = rep(0, times = 1000)
RMSE_trn7_1 = rep(0, times = 1000)
RMSE_trn8_1 = rep(0, times = 1000)
RMSE_trn9_1 = rep(0, times = 1000)
RMSE_trn1_2 = rep(0, times = 1000)
RMSE_trn2_2 = rep(0, times = 1000)
RMSE_trn3_2 = rep(0, times = 1000)
RMSE_trn4_2 = rep(0, times = 1000)
RMSE_trn5_2 = rep(0, times = 1000)
RMSE_trn6_2 = rep(0, times = 1000)
RMSE_trn7_2 = rep(0, times = 1000)
RMSE_trn8_2 = rep(0, times = 1000)
RMSE_trn9_2 = rep(0, times = 1000)
RMSE_trn1_3 = rep(0, times = 1000)
RMSE_trn2_3 = rep(0, times = 1000)
RMSE_trn3_3 = rep(0, times = 1000)
RMSE_trn4_3 = rep(0, times = 1000)
RMSE_trn5_3 = rep(0, times = 1000)
RMSE_trn6_3 = rep(0, times = 1000)
RMSE_trn7_3 = rep(0, times = 1000)
RMSE_trn8_3 = rep(0, times = 1000)
RMSE_trn9_3 = rep(0, times = 1000)
RMSE_tst1_1 = rep(0, times = 1000)
RMSE_tst2_1 = rep(0, times = 1000)
RMSE_tst3_1 = rep(0, times = 1000)
RMSE_tst4_1 = rep(0, times = 1000)
RMSE_tst5_1 = rep(0, times = 1000)
RMSE_tst6_1 = rep(0, times = 1000)
RMSE_tst7_1 = rep(0, times = 1000)
RMSE_tst8_1 = rep(0, times = 1000)
RMSE_tst9_1 = rep(0, times = 1000)
RMSE_tst1_2 = rep(0, times = 1000)
RMSE_tst2_2 = rep(0, times = 1000)
RMSE_tst3_2 = rep(0, times = 1000)
RMSE_tst4_2 = rep(0, times = 1000)
RMSE_tst5_2 = rep(0, times = 1000)
RMSE_tst6_2 = rep(0, times = 1000)
RMSE_tst7_2 = rep(0, times = 1000)
RMSE_tst8_2 = rep(0, times = 1000)
RMSE_tst9_2 = rep(0, times = 1000)
RMSE_tst1_3 = rep(0, times = 1000)
RMSE_tst2_3 = rep(0, times = 1000)
RMSE_tst3_3 = rep(0, times = 1000)
RMSE_tst4_3 = rep(0, times = 1000)
RMSE_tst5_3 = rep(0, times = 1000)
RMSE_tst6_3 = rep(0, times = 1000)
RMSE_tst7_3 = rep(0, times = 1000)
RMSE_tst8_3 = rep(0, times = 1000)
RMSE_tst9_3 = rep(0, times = 1000)
y_hat_1_1 = rep(0, times = 1000)



```

**Methods** : In this simulation study, We will use the following for loop for 27 times to creat 27000 train RMSE and test RMSE. The next step is to calculate the mean of RMSE_TRN AND RMSE_TST for each model for each $\sigma$. 

```{r, eval = FALSE}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_1 = lm(y ~ x1, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_1, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_1, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn1_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst1_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
```

```{r,echo = FALSE}
set.seed(birthday)
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_1 = lm(y ~ x1, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_1, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_1, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn1_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst1_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_2 = lm(y ~ x1 + x2, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_2, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_2, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn2_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst2_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_3 = lm(y ~ x1 + x2 + x3, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_3, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_3, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn3_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst3_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_4 = lm(y ~ x1 + x2 + x3 + x4, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_4, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_4, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn4_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst4_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_5 = lm(y ~ x1 + x2 + x3 + x4 + x5, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_5, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_5, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn5_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst5_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_6 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_6, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_6, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn6_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst6_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_7 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_7, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_7, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn7_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst7_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_8 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_8, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_8, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn8_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst8_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}

for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 1)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  trn_model_9 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9, data = sim_data_2)
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_9, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_9, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn9_1[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst9_1[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_1, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_1, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn1_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst1_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_2, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_2, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn2_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst2_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_3, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_3, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn3_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst3_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_4, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_4, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn4_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst4_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_5, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_5, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn5_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst5_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_6, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_6, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn6_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst6_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_7, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_7, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn7_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst7_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_8, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_8, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn8_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst8_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 2)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_9, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_9, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn9_2[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst9_2[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_1, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_1, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn1_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst1_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_2, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_2, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn2_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst2_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}

for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_3, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_3, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn3_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst3_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_4, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_4, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn4_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst4_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_5, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_5, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn5_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst5_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_6, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_6, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn6_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst6_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_7, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_7, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn7_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst7_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_8, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_8, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn8_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst8_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}
for (i in 1:1000) {
  eps = rnorm(500, mean = 0, sd = 4)
  
  sim_data_2$y = beta_0 + beta_1 * x1 + beta_3 * x3 + beta_4 * x4 + beta_5 *
    x5 + beta_6 * x6 + eps
  
  trn_data = sim_data_2[sim_2_trn,]
  tst_data = sim_data_2[sim_2_tst,]
  y_hat_1 = predict(trn_model_9, newdata = trn_data)
  y_hat_1_tst = predict(trn_model_9, newdata = tst_data)
  y_trn = trn_data$y
  y_tst = tst_data$y
  RMSE_trn9_3[i] = sqrt(mean((y_trn - y_hat_1) ^ 2))
  RMSE_tst9_3[i] = sqrt(mean((y_tst - y_hat_1_tst) ^ 2))
}

```

**Result** : The result will be plots with the mean of RMSE_TRN and RMSE_TST as responses and the model size as predictor.
Since there are three different $\sigma$, we will have 3 plots.

```{r,echo = FALSE}

Y1 = c(
  mean(RMSE_trn1_1),
  mean(RMSE_trn2_1),
  mean(RMSE_trn3_1),
  mean(RMSE_trn4_1),
  mean(RMSE_trn5_1),
  mean(RMSE_trn6_1),
  mean(RMSE_trn7_1),
  mean(RMSE_trn8_1),
  mean(RMSE_trn9_1)
)
Y2 = c(
  mean(RMSE_tst1_1),
  mean(RMSE_tst2_1),
  mean(RMSE_tst3_1),
  mean(RMSE_tst4_1),
  mean(RMSE_tst5_1),
  mean(RMSE_tst6_1),
  mean(RMSE_tst7_1),
  mean(RMSE_tst8_1),
  mean(RMSE_tst9_1)
)
X1 = seq(1, 9, by = 1)
plot(
  Y1 ~ X1,
  pch = 20,
  col = "Orange",
  xlab = "Model Size",
  ylab = "RMSE",
  main = "Models when sigma = 1"
)
points(X1, Y2, pch = 20, col = "Navyblue")
legend(
  6.8,
  2.2,
  c("AVG_TRN_RMSE", "AVG_TST_RMSE"),
  col = c("Orange", "Navyblue"),
  text.col = c("Orange", "Navyblue"),
  pch = 20
)


```
```{r,echo = FALSE}
Y1 = c(
  mean(RMSE_trn1_2),
  mean(RMSE_trn2_2),
  mean(RMSE_trn3_2),
  mean(RMSE_trn4_2),
  mean(RMSE_trn5_2),
  mean(RMSE_trn6_2),
  mean(RMSE_trn7_2),
  mean(RMSE_trn8_2),
  mean(RMSE_trn9_2)
)
Y2 = c(
  mean(RMSE_tst1_2),
  mean(RMSE_tst2_2),
  mean(RMSE_tst3_2),
  mean(RMSE_tst4_2),
  mean(RMSE_tst5_2),
  mean(RMSE_tst6_2),
  mean(RMSE_tst7_2),
  mean(RMSE_tst8_2),
  mean(RMSE_tst9_2)
)
X1 = seq(1, 9, by = 1)
plot(
  Y1 ~ X1,
  pch = 20,
  col = "Orange",
  xlab = "Model Size",
  ylab = "RMSE",
  main = "Models when sigma = 2"
)
points(X1, Y2, pch = 20, col = "Navyblue")
legend(
  6.8,
  2.8,
  c("AVG_TRN_RMSE", "AVG_TST_RMSE"),
  col = c("Orange", "Navyblue"),
  text.col = c("Orange", "Navyblue"),
  pch = 20
)
```

```{r,echo = FALSE}
Y1 = c(
  mean(RMSE_trn1_3),
  mean(RMSE_trn2_3),
  mean(RMSE_trn3_3),
  mean(RMSE_trn4_3),
  mean(RMSE_trn5_3),
  mean(RMSE_trn6_3),
  mean(RMSE_trn7_3),
  mean(RMSE_trn8_3),
  mean(RMSE_trn9_3)
)
Y2 = c(
  mean(RMSE_tst1_3),
  mean(RMSE_tst2_3),
  mean(RMSE_tst3_3),
  mean(RMSE_tst4_3),
  mean(RMSE_tst5_3),
  mean(RMSE_tst6_3),
  mean(RMSE_tst7_3),
  mean(RMSE_tst8_3),
  mean(RMSE_tst9_3)
)
X1 = seq(1, 9, by = 1)
plot(
  Y1 ~ X1,
  pch = 20,
  col = "Orange",
  xlab = "Model Size",
  ylab = "RMSE",
  main = "Models when sigma = 4"
)
points(X1, Y2, pch = 20, col = "Navyblue")
legend(
  6.8,
  4.4,
  c("AVG_TRN_RMSE", "AVG_TST_RMSE"),
  col = c("Orange", "Navyblue"),
  text.col = c("Orange", "Navyblue"),
  pch = 20
)


```


**Discussion** : The plots show that as the model size getting bigger(more predictors in the model), both test RMSE and train RMSE getting smaller until the model size reaches to 6, since the original model have 6 predictors. The model 6,7,8,9 (use all possible predictors) are better for predicting the response since it has relatively small train rmse and  test rmse, which means they make smaller (squared) errors on average. However, the method can not always select the correct model, we can see that the RMSE for model 6,7,8,9 are basically the same, on average it can select the correct model. 
As the $\sigma$ getting bigger, the RMSE gets bigger, which means more (squared) erros on average.


# Simulation Study 3: Power (Graduate Students only)

In this simulation study we will investigate the **power** of the significance of regression test for simple linear regression. 

\[
H_0: \beta_{1} = 0 \ \text{vs} \ H_1: \beta_{1} \neq 0
\]

Recall, we had defined the *significance* level, $\alpha$, to be the probability of a Type I error.

\[
\alpha = P[\text{Reject } H_0 \mid H_0 \text{ True}] = P[\text{Type I Error}]
\]

Similarly, the probability of a Type II error is often denoted using $\beta$; however, this should not be confused with a regression parameter.

\[
\beta = P[\text{Fail to Reject } H_0 \mid H_1 \text{ True}] = P[\text{Type II Error}]
\]

*Power* is the probability of rejecting the null hypothesis when the null is not true, that is, the alternative is true and $\beta_{1}$ is non-zero.

\[
\text{Power} = 1 - \beta = P[\text{Reject } H_0 \mid H_1 \text{ True}]
\]

Essentially, power is the probability that a signal of a particular strength will be detected. Many things affect the power of a test. In this case, some of those are:

- Sample Size, $n$
- Signal Strength, $\beta_1$
- Noise Level, $\sigma$
- Significance Level, $\alpha$

We'll investigate the first three.

To do so we will simulate from the model

\[
Y_i = \beta_0 + \beta_1 x_i + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$.

For simplicity, we will let $\beta_0 = 0$, thus $\beta_1$ is essentially controlling the amount of "signal." We will then consider different signals, noises, and sample sizes:

- $\beta_1 \in (-2, -1.9, -1.8, \ldots, -0.1, 0, 0.1, 0.2, 0.3, \ldots 1.9, 2)$
- $\sigma \in (1, 2, 4)$
- $n \in (10, 20, 30)$

We will hold the significance level constant at $\alpha = 0.05$.

Use the following code to generate the predictor values, `x`: values for different sample sizes.

```{r eval=FALSE}
x_values = seq(0, 5, length = n)
```

For each possible $\beta_1$ and $\sigma$ combination, simulate from the true model at least $1000$ times. Each time, perform the significance of the regression test. To estimate the power with these simulations, and some $\alpha$, use

\[
\hat{\text{Power}} = \hat{P}[\text{Reject } H_0 \mid H_1 \text{ True}] = \frac{\text{# Tests Rejected}}{\text{# Simulations}}
\]

It is *possible* to derive an expression for power mathematically, but often this is difficult, so instead, we rely on simulation.

Create three plots, one for each value of $\sigma$. Within each of these plots, add a “power curve” for each value of $n$ that shows how power is affected by signal strength, $\beta_1$.

Potential discussions:

- How do $n$, $\beta_1$, and $\sigma$ affect power? Consider additional plots to demonstrate these effects.
- Are $1000$ simulations sufficient?
